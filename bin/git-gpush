#!/usr/bin/perl
# Copyright (C) 2017 The Qt Company Ltd.
# Contact: http://www.qt.io/licensing/
#
# You may use this file under the terms of the 3-clause BSD license.
# See the file LICENSE from this package for details.
#

use strict;
use warnings;

our ($script, $script_path);
BEGIN {
    use Cwd qw(abs_path);
    if ($^O eq "msys") {
        $0 =~ s,\\,/,g;
        $0 =~ s,^(.):/,/$1/,g;
    }
    $script_path = $script = abs_path($0);
    $script_path =~ s,/[^/]+$,,;
    unshift @INC, $script_path;
}
use git_gpush;

# Cannot use Pod::Usage for this file, since git on Windows will invoke its own perl version, which
# may not (msysgit for example) support this module, even if it's considered a Core module.
sub usage
{
    print << "EOM";
Usage:
    git gpush [opts] [sha1/ref-from] [+<reviewer>] [=<CC user>]

    Pushes Changes to Gerrit and adds reviewers and CC to the PatchSets.

Description:
    This program is used to push PatchSets to Gerrit, and at the same
    time add reviewers and CCs to the PatchSets pushed.

    You can use email addresses, Gerrit usernames, or aliases for the
    name of the reviewers/CCs.

    The pushed commits are listed by default. Conforming with Gerrit,
    these are the commits which are not on any branch of the pushed
    branch's upstream remote.

    If no sha1 or ref-from is specified, 'HEAD' is used.

    Note that this program can be used in the middle of an interactive
    rebase, to push out the amended commits instantly.

Options:
    -f, --force
        Push despite newer PatchSets being on Gerrit.

    -r, --remote
        Specify the git remote to push to.

    -b, --branch
        Specify the git branch to push for. If not specified, the
        upstream branch for 'ref-from' is used as the target branch.
        This setting persists for the series, even when it grows.

    -fb, --force-branch
        Push for specified branch despite the pushed Changes having
        been pushed previously, but only for different branches.

    -l, --list
        Report all Changes that would be pushed, then quit.
        This is a purely off-line operation.

    -ll, --list-online
        Report all Changes that would be pushed, then quit.
        The Changes are annotated with state information from Gerrit.

    --aliases
        Report all registered aliases and quit.

    -n, --dry-run
        Do everything except actually pushing commits and updating state.
        This is useful mostly for debugging.

    -v, --verbose
        Show the resolved aliases, SHA1s of commits, and other information.

    -q, --quiet
        Suppress the usual output about what is pushed where.

    --debug
        Print debug information.

Configuration:
    This program uses options from the git configuration. All its keys
    use the 'gpush.' prefix. Consequently, to configure any option, you
    can use a command like this:
        git config --global gpush.<the option> <the value>
    If you want it to be local to the current repository, just drop the
    --global option. The following options are supported:

    alias.<alias>
        An alias definition. The value is a comma-separated list of Gerrit
        login names and/or email addresses, so it's possible to map, for
        example, IRC nicknames or entire teams. Note that git config keys
        are constrained regarding allowed characters, so it is impossible
        to map some IRC nicks via git configuration; see below for an
        alternative.

    remote
        The default git remote to use for pushing to Gerrit.
        When not configured, 'gerrit' is used if present, otherwise the
        pushed branch's upstream remote is used.

    upstream
        The git remote to assume to be the upstream if the pushed branch
        does not have a remote-tracking branch configured.
        Defaults to 'origin' or the only present remote if not configured.

    In addition to the git configuration (which takes precedence), the file
    .git-gpush-aliases located next to this program is also read. It may
    contain two sections: 'config' where you can use the options specified
    above, and 'aliases'. The latter works just like alias definitions via
    the git configuration, except that:
    - The alias name itself may also be a comma-separated list, thus
      supporting users with multiple handles.
    - Most characters are permitted in the alias names.

Copyright:
    Copyright (C) 2017 The Qt Company Ltd.
    Contact: http://www.qt.io/licensing/

License:
    You may use this file under the terms of the 3-clause BSD license.
EOM
}

my $ref_from;
my $ref_to;
my $force_branch = 0;
my $force = 0;
my $list_only = 0;
my $list_online = 0;

my @reviewers;
my @CCs;

sub parse_arguments(@)
{
    while (scalar @_) {
        my $arg = shift @_;

        if ($arg eq "-v" || $arg eq "--verbose") {
            $verbose = 1;
        } elsif ($arg eq "-q" || $arg eq "--quiet") {
            $quiet = 1;
        } elsif ($arg eq "--debug") {
            $debug = 1;
            $verbose = 1;
        } elsif ($arg eq "-n" || $arg eq "--dry-run") {
            $dry_run = 1;
        } elsif ($arg eq "-f" || $arg eq "--force") {
            $force = 1;
        } elsif ($arg eq "-r" || $arg eq "--remote") {
            fail("--remote needs an argument.\n") if (!@_ || ($_[0] =~ /^-/));
            $remote = shift @_;
        } elsif ($arg eq "-b" || $arg eq "--branch") {
            fail("--branch needs an argument.\n") if (!@_ || ($_[0] =~ /^-/));
            $ref_to = shift @_;
        } elsif ($arg eq "-fb" || $arg eq "--force-branch") {
            $force_branch = 1;
        } elsif ($arg eq "-l" || $arg eq "--list") {
            $list_only = 1;
        } elsif ($arg eq "-ll" || $arg eq "--list-online") {
            $list_only = 1;
            $list_online = 1;
        } elsif ($arg eq "--aliases") {
            foreach my $key (sort(keys %aliases)) {
                print "$key = $aliases{$key}\n";
            }
            exit 0;
        } elsif ($arg eq "-?" || $arg eq "--?" || $arg eq "-h" || $arg eq "--help") {
            usage();
            exit 0;
        } elsif ($arg =~ /^\+(.+)/) {
            push @reviewers, split(/,/, lookup_alias($1));
        } elsif ($arg =~ /^\=(.+)/) {
            push @CCs, split(/,/, lookup_alias($1));
        } elsif ($arg !~ /^\-/) {
            fail("Specifying multiple sources is currently not supported.\n")
                if (defined($ref_from));
            if ($arg =~ /(.*):(.*)/) {
                if (length($1)) {
                    $ref_from = $1;
                    print STDERR "Warning: Specifying <ref-from>: is deprecated.".
                                 " Use just <ref-from> instead.\n";
                }
                if (length($2)) {
                    $ref_to = $2;
                    print STDERR "Warning: Specifying :<ref-to> is deprecated.".
                                 " Use --branch instead.\n";
                }
            } else {
                $ref_from = $arg;
            }
        } else {
            fail("Unrecognized option '$arg'.\n");
        }
    }

    fail("--quiet and --verbose/--debug are mutually exclusive.\n")
        if ($quiet && $verbose);

    if (!defined($ref_from)) {
        $ref_from = "HEAD";
    }

    my $push_specific =
            @reviewers || @CCs || $force || $force_branch
            || defined($remote) || defined($ref_to);

    if ($list_only) {
        fail("--list/--list-online is incompatible with --quiet/--verbose.\n")
            if ($quiet || ($verbose && !$debug));
        fail("--list/--list-online is incompatible with push-modifying options.\n")
            if ($push_specific);
    }
}

sub process_config()
{
    load_config();
}

sub lookup_alias($)
{
    my ($user) = @_;

    my $alias = $aliases{$user};
    if (defined $alias && $alias ne "") {
        print "Resolved $user to $alias.\n" if ($verbose);
        return $alias;
    }

    return $user;
}

sub set_group_error($$$)
{
    my ($group, $style, $error) = @_;

    ($$group{error_style}, $$group{error}) = ($style, $error);
}

sub caption_group($)
{
    my ($group) = @_;

    my $changes = $$group{changes};
    my $to = $$group{branch};
    my $tos = defined($to) ? " for $to" : "";
    my ($pfx, $rmt) = $list_only
                          ? ("Series of",
                             ($list_online && length($tos)) ? " on '$remote'" : "")
                          : ("Pushing", " to '$remote'");
    return (sprintf("%s %d Change(s)%s%s:",
                    $pfx, int(@$changes), $tos, $rmt),
            $changes);
}

sub report_pushed_group($$)
{
    my ($reports, $group) = @_;

    my ($title, $changes) = caption_group($group);
    report_flowed($reports, $title);
    report_local_changes($reports, $changes);
    my $error = $$group{error};
    report_text($reports, $$group{error_style}, $error) if (defined($error));
}

sub report_pushed_changes($)
{
    my ($group) = @_;

    my @reports;
    report_pushed_group(\@reports, $group);
    return \@reports;
}

# Determine a singular value for a particular attribute from the Changes
# in a series. Conflicting values are an error.
sub aggregate_property($$$$)
{
    my ($group, $prop_name, $get_prop, $get_ann) = @_;

    my $changes = $$group{changes};
    my %prop_map = map { $_ => 1 } grep { $_ } map { $get_prop->($_) } @$changes;
    my @props = keys %prop_map;
    if (@props > 1) {
        foreach my $change (@$changes) {
            my $p = $get_prop->($change);
            $$change{annotation} = $get_ann->($p) if (defined($p));
        }
        set_group_error($group, 'flowed',
                        "Changes were previously pushed with mixed ${prop_name}s."
                        ." Please specify one.");
        fail_formatted(report_pushed_changes($group));
    }
    if (@props) {
        my $p = $props[0];
        print "Re-using $prop_name '$p'.\n" if ($debug);
        return $p;
    }
    return undef;
}

# Find _the_ branch the specified commit lives on. This can be the current
# branch (and other branches are ignored), or _one_ other branch.
sub branch_for_commit($)
{
    my ($commit) = @_;

    my $curbranch;
    my @otherbranches;
    my $branches = open_cmd_pipe(0, "git", "branch", "--contains", $commit);
    while (read_process($branches)) {
        if (/^\* \(/) {
            # New git versions will tell us the currently rebased branch.
            if (/^\* \(no branch, rebasing (.*)\)$/) {
                $curbranch = $1;
            }
            last;
        } elsif (/^\* (.*)$/) {
            $curbranch = $1;
            last;
        } elsif (/^  (.*)$/) {
            push @otherbranches, $1;
        }
    }
    close_process($branches);
    if (!defined($curbranch)) {
        # If the commit is not on the current branch, see if it is on _one_
        # other branch with an upstream branch.
        my @goodbranches;
        foreach my $other (@otherbranches) {
            push @goodbranches, $other if (defined(git_config("branch.$other.merge")));
        }
        $curbranch = $goodbranches[0] if (@goodbranches == 1);
    }
    return $curbranch;
}

# Extract the local branch from the specified source.
# There are four possibilities where the source revision may be located:
# - On any named branch in a regular state.
#   The branch is usable up to its tip, which may be pointed to by HEAD.
# - On the current named branch mid-rebase.
#   The branch is pointed to by HEAD, and is usable only up to this point.
# - On a detached head, possibly mid-rebase.
#   HEAD is the only reference and thus also the tip. There is no name.
# - Nowhere, except possibly in the reflog.
#   It is the tip, as there are no references. There is no name.
# Note that commits specified by SHA1 which live on exactly one named
# branch fall into the first case.
sub determine_local_branch()
{
    # Validate the source commit, to avoid confusing errors later.
    run_process(FWD_STDERR, "git", "rev-parse", $ref_from, '--');

    # First, try to extract a branch name directly.
    $local_branch = ($ref_from =~ s/[~^].*$//r);
    if ($local_branch eq "HEAD") {
        my $sref = read_cmd_line(SOFT_FAIL, "git", "symbolic-ref", "-q", "HEAD");
        $local_branch = $sref if (!$?);
    }
    $local_branch =~ s,^refs/heads/,,;
    if (!defined($local_refs{$local_branch})) {
        # Next, try to deduce a branch from the commit.
        $local_branch = branch_for_commit($ref_from);
    }
    setup_remotes($ref_from);
    set_gerrit_config($remote);
}

# Determine the target branch for the given series.
# The local branch's upstream branch will be used, unless a target branch
# has been specified by the user.
sub determine_remote_branch($)
{
    my ($group) = @_;

    my $br = $ref_to;
    if (!defined($br)) {
        $br = aggregate_property($group, 'target',
                                 sub { $_[0]->{tgt} },
                                 sub { '  => '.$_[0] });
    }
    if (!defined($br)) {
        fail("Cannot deduce source branch for $ref_from. Please use --branch.\n")
            if (!defined($local_branch));
        $br = git_config("branch.$local_branch.merge");
        fail("$local_branch has no upstream branch. Please use --branch.\n")
            if (!defined($br));
        $br =~ s,^refs/heads/,,;
    }
    $$group{branch} = $br;
}

sub finalize_get_changes($)
{
    my ($changes) = @_;

    my %group = (changes => $changes);
    return \%group;
}

# Get the list of local commits to push.
sub get_changes()
{
    my $commits = analyze_local_branch($ref_from);
    my $changes = changes_from_commits($commits);
    fail("Specified commit range is empty.\n") if (!@$changes);
    my $group = finalize_get_changes($changes);
    return $group;
}

# Assign each local Change to a matching remote Change if possible,
# on the way complaining about creating duplicates.
sub map_remote_changes($)
{
    my ($group) = @_;

    my $changes = $$group{changes};
    my $br = $$group{branch};
    my (@bad_chg, %bad_br);
    foreach my $change (@$changes) {
        my $gis = $gerrit_infos_by_id{$$change{id}};
        next if (!$gis);
        my ($good, @bad);
        foreach my $gi (@$gis) {
            if ($$gi{branch} eq $br) {
                $good = $gi;
            } elsif ($$gi{status} ne "MERGED") {
                # MERGED Changes are ignored, to avoid false positives for cherry-picks.
                push @bad, $gi;
            }
        }
        if ($good) {
            $$change{gerrit} = $good;
        } elsif (@bad && !$force_branch) {
            my @bbr = map { $$_{branch} } @bad;
            $$change{annotation} = '  ['.join(" ", sort @bbr).']';
            push @bad_chg, $change;
            $bad_br{$_} = 1 foreach (@bbr);
        }
    }
    if (@bad_chg) {
        my $reports = report_pushed_changes($group);
        my $tpfx = (@bad_chg == @$changes) ? "The" : "Some of the";
        my $tsfx = (keys(%bad_br) == 1) ? "a different branch" : "different branches";
        report_fixed($reports,
                     "$tpfx Change(s) were previously pushed only for $tsfx.\n",
                     "Please move them server-side, push for a matching branch,\n",
                     "or use --force-branch to continue nonetheless.\n");
        fail_formatted($reports);
    }
}

use constant {
    NEW => 'NEW',
    FORCE => 'FORCE',
    MISSING => 'MISSING',
    MODIFIED => 'MODIFIED',
    UNMODIFIED  => 'UNMODIFIED',
    OUTDATED => 'OUTDATED',
    MERGED => 'MERGED',
    REJECTED => 'REJECTED'
};

sub classify_changes_offline($)
{
    my ($group) = @_;

    foreach my $change (@{$$group{changes}}) {
        my $pushed = $$change{pushed};
        if (defined($pushed)) {
            my $commit = $$change{local}{id};
            if ($commit eq $pushed) {
                $$change{freshness} = UNMODIFIED;
            } else {
                $$change{freshness} = MODIFIED;
            }
        } else {
            $$change{freshness} = NEW;
        }
    }
}

my $have_rejected = 0;
my $have_modified = 0;
my $need_force = 0;

sub classify_changes_online($)
{
    my ($group) = @_;

    foreach my $change (@{$$group{changes}}) {
        my $commit = $$change{local};
        my $sha1 = $$commit{id};
        my $ginfo = $$change{gerrit};
        my $status = $ginfo && $$ginfo{status};
        my $curr_sha1 = $ginfo && $$ginfo{revs}[-1]{id};
        my $chg_revs = $ginfo && $$ginfo{rev_by_id};
        my $this_rev = $chg_revs && $$chg_revs{$sha1};
        if ($this_rev) {
            $$change{patchset} = $$this_rev{ps};
            $$change{freshness} =
                ($status eq 'MERGED') ? MERGED :
                ($sha1 eq $curr_sha1) ? UNMODIFIED : OUTDATED;
        } elsif ($ginfo && ($status ne 'NEW')) {
            # We are attempting a push which Gerrit will reject anyway.
            my $err;
            if ($status eq 'MERGED') {
                $err = "Change is already MERGED; please pull/rebase.";
            } elsif ($status eq 'STAGED' || $status eq 'INTEGRATING') {
                $err = "Change is currently $status; cannot proceed.";
            } elsif ($status eq 'DEFERRED' || $status eq 'ABANDONED') {
                $err = "Change is $status; please restore it first.";
            } else {
                $err = "Change is in unknown state '$status'. I'm stumped. :}";
            }
            set_change_error($change, 'oneline', $err);
            $$change{freshness} = REJECTED;
            $have_rejected++;
        } else {
            # Finally, check whether the current PatchSet on Gerrit meets our
            # expectations, so we don't accidentally play ping-pong.
            my $pushed = $$change{pushed};
            if ($ginfo) {
                if (!defined($pushed) || ($pushed ne $curr_sha1)) {
                    my $pushed_rev = defined($pushed) && $$chg_revs{$pushed};
                    $$change{patchset} = $pushed_rev ? $$pushed_rev{ps} : "?";
                    $$change{freshness} = FORCE;
                    $need_force = 1;
                } else {
                    $$change{freshness} = MODIFIED;
                }
            } else {
                if (defined($pushed)) {
                    $$change{freshness} = MISSING;
                    $need_force = 1;
                } else {
                    $$change{freshness} = NEW;
                }
            }
            $have_modified++;
        }
    }
}

sub annotate_changes($)
{
    my ($group) = @_;

    foreach my $change (@{$$group{changes}}) {
        my @attribs;
        # Changes in the 'modified' state (that is, the ones for which pushing
        # actually has an effect) are annotated, while 'unmodified' ones are not.
        # This behavior has been chosen after much deliberation following the
        # principle that "no-op" should be silent, despite the fact that "doing
        # nothing" is a diversion from what a regular git push would do, and is
        # thus potentially confusing - but as having no modified changes at all
        # leads to an additional message, the less noisy output (assuming that
        # most Changes are usually not modified) seems most sensible.
        my $freshness = $$change{freshness};
        if ($freshness ne UNMODIFIED) {
            $freshness = "PS$$change{patchset}/$freshness"
                if ($freshness eq OUTDATED || $freshness eq FORCE);
            push @attribs, $freshness;
        }
        $$change{annotation} = '  ['.join('; ', @attribs).']'
            if (@attribs);
    }
}

sub make_listing($)
{
    my ($group) = @_;

    annotate_changes($group);
    return report_pushed_changes($group);
}

sub show_changes($)
{
    my ($group) = @_;

    print format_reports(make_listing($group));
}

sub fail_push($@)
{
    my ($group, @msgs) = @_;

    my $reports = make_listing($group);
    report_fixed($reports, @msgs);
    fail_formatted($reports);
}

sub print_errors($)
{
    my ($group) = @_;

    fail_push($group, "Giving up - push is going to be rejected.\n")
        if ($have_rejected);
    fail_push($group, "Local state is out of sync with Gerrit.\n",
                      "Please specify --force to push nonetheless.\n")
        if ($need_force && !$force);
}

sub push_changes($)
{
    my ($group) = @_;

    my $from = $$group{changes}[-1];
    my $tip = $$from{local}{id};
    my $to = $$group{branch};

    my @push_options;
    push @push_options, map { "r=$_" } @reviewers;
    push @push_options, map { "cc=$_" } @CCs;

    my @gitcmd = ("git", "push");
    push @gitcmd, '-v' if ($verbose);
    push @gitcmd, '-q' if ($quiet);
    push @gitcmd, '-n' if ($dry_run);
    push @gitcmd, map { ("-o", "$_") } @push_options;
    push @gitcmd, $remote, "$tip:refs/for/$to";

    run_process(FWD_OUTPUT, @gitcmd);
}

sub update_state($)
{
    my ($group) = @_;

    my $branch = $$group{branch};
    foreach my $change (@{$$group{changes}}) {
        my $sha1 = $$change{local}{id};
        $$change{pushed} = $sha1;
        $$change{tgt} = $branch;
    }
}

sub execute_pushing()
{
    my $online = !$list_only || $list_online;
    my $group = get_changes();
    my $pushed_changes = $$group{changes};
    if ($online) {
        my @queries = map { "change:".$$_{id} } @$pushed_changes;
        query_gerrit(\@queries);
    }
    determine_remote_branch($group);
    if ($online) {
        map_remote_changes($group);
        classify_changes_online($group);
    } elsif (!$quiet) {
        classify_changes_offline($group);
    }
    if ($list_only) {
        show_changes($group);
        print "Not pushing - list mode.\n" if ($debug);
    } else {
        print_errors($group);
        show_changes($group) if (!$quiet);
        if ($have_modified) {
            push_changes($group);
        } else {
            print "No modified commits - nothing to push.\n" if (!$quiet);
        }

        # This makes sense even if no modified commits are pushed
        # (e.g., syncing state after a dumb push).
        update_state($group);
    }
}

process_config();
parse_arguments(@ARGV);
goto_gitdir();
load_state();
determine_local_branch();
execute_pushing();
save_state($dry_run);
