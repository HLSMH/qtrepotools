#!/usr/bin/perl
# Copyright (C) 2017 The Qt Company Ltd.
# Copyright (C) 2014 Intel Corporation.
# Copyright (C) 2019 Oswald Buddenhagen
# Contact: http://www.qt.io/licensing/
#
# You may use this file under the terms of the 3-clause BSD license.
# See the file LICENSE from this package for details.
#

use v5.14;
use strict;
use warnings;

our ($script, $script_path);
BEGIN {
    use Cwd qw(abs_path);
    if ($^O eq "msys") {
        $0 =~ s,\\,/,g;
        $0 =~ s,^(.):/,/$1/,g;
    }
    $script_path = $script = abs_path($0);
    $script_path =~ s,/[^/]+$,,;
    unshift @INC, $script_path;
}
use git_gpush;

use JSON;

# Cannot use Pod::Usage for this file, since git on Windows will invoke its own perl version, which
# may not (msysgit for example) support this module, even if it's considered a Core module.
sub usage
{
    print << "EOM";
Usage:
    git gpush [opts] [from] [+<reviewer>] [=<CC user>]

    Pushes Changes to Gerrit and adds reviewers and CC to the PatchSets.

Description:
    This program is used to push PatchSets to Gerrit, and at the same
    time add reviewers and CCs to the PatchSets pushed.

    You can use email addresses, Gerrit usernames, or aliases for the
    name of the reviewers/CCs.

    The pushed commits are listed by default. Conforming with Gerrit,
    these are the commits which are not on any branch of the pushed
    branch's upstream remote.

    Prior to actually pushing any commits, gpush will temporarily rebase
    them onto a new base. This has the advantage that you can keep many
    unrelated "series" in your local branch without creating spurious
    dependencies on Gerrit, effectively pretending that you have a separate
    branch for every series. Furthermore, you can keep the base of
    subsequent pushes of the same series constant, which means that you
    can closely track the upstream branch without pushing needless rebases
    to Gerrit (which would obfuscate inter-PatchSet diffs).

    'From' may be specified as either a ref, a SHA1, or a Gerrit Change-Id,
    possibly abbreviated. Git rev-spec suffixes like '~2' are allowed; if
    only a suffix is specified, it is understood to be relative to 'HEAD'.
    'From' may also be a range, specified as either <base>..<tip> or
    <tip>:<count>. Both <base> and <tip> may be omitted, in which case
    they default to '\@{upstream}' and 'HEAD', respectively.
    If 'from' is not specified, 'HEAD' is used.

    Note that this program can be used in the middle of an interactive
    rebase, to push out the amended commits instantly.

Options:
    -f, --force
        Push despite newer PatchSets being on Gerrit.

    -r, --remote
        Specify the git remote to push to.

    -b, --branch
        Specify the git branch to push for. If not specified, 'from's
        upstream branch is used as the target branch.
        This setting persists for the series, even when it grows.

    -fb, --force-branch
        Push for specified branch despite the pushed Changes having
        been pushed previously, but only for different branches.

    -t, --topic
        Specify the Gerrit topic name for the pushed Changes.
        This setting persists for the series, even when it grows.

    -o, --onto, --base
        Specify the commit to rebase the pushed series onto. It is possible
        to specify arbitrary other commits already known to Gerrit, including
        still pending PatchSets. Use 'ROOT' to orphan the series.
        If no base is specified, gpush will use the head of the target branch
        on the gerrit remote. That means that you can set a new default base
        by fetching your gerrit remote, which you should do much less often
        than fetching the origin remote.

    -l, --list
        Report all Changes that would be pushed, then quit.
        This is a purely off-line operation.

    -ll, --list-online
        Report all Changes that would be pushed, then quit.
        The Changes are annotated with state information from Gerrit.

    --aliases
        Report all registered aliases and quit.

    -n, --dry-run
        Do everything except actually pushing commits and updating state.
        This is useful mostly for debugging.

    -v, --verbose
        Show the resolved aliases, SHA1s of commits, and other information.

    -q, --quiet
        Suppress the usual output about what is pushed where.

    --debug
        Print debug information.

Configuration:
    This program uses options from the git configuration. All its keys
    use the 'gpush.' prefix. Consequently, to configure any option, you
    can use a command like this:
        git config --global gpush.<the option> <the value>
    If you want it to be local to the current repository, just drop the
    --global option. The following options are supported:

    alias.<alias>
        An alias definition. The value is a comma-separated list of Gerrit
        login names and/or email addresses, so it's possible to map, for
        example, IRC nicknames or entire teams. Note that git config keys
        are constrained regarding allowed characters, so it is impossible
        to map some IRC nicks via git configuration; see below for an
        alternative.

    remote
        The default git remote to use for pushing to Gerrit.
        When not configured, 'gerrit' is used if present, otherwise the
        pushed branch's upstream remote is used.

    upstream
        The git remote to assume to be the upstream if the pushed branch
        does not have a remote-tracking branch configured.
        Defaults to 'origin' or the only present remote if not configured.

    In addition to the git configuration (which takes precedence), the file
    .git-gpush-aliases located next to this program is also read. It may
    contain two sections: 'config' where you can use the options specified
    above, and 'aliases'. The latter works just like alias definitions via
    the git configuration, except that:
    - The alias name itself may also be a comma-separated list, thus
      supporting users with multiple handles.
    - Most characters are permitted in the alias names.

Examples:
    git gpush .. +alex
        Push HEAD and its ancestors for the upstream branch of HEAD,
        rebased on top of the current tip of that branch, and add 'alex'
        as a reviewer.

    git gpush I2c9ccbc26..I9434d28fc
        Push the range identified by Gerrit Change-Ids for the upstream
        branch of HEAD, rebased on top of the current tip of that branch.

    git gpush ~1:3 -b 5.4 -o 85af7f4538b
        Push the range HEAD~4..HEAD~1 for branch 5.4, rebased on top of
        commit 85af7f4538b.

Copyright:
    Copyright (C) 2017 The Qt Company Ltd.
    Copyright (C) 2014 Intel Corporation.
    Copyright (C) 2019 Oswald Buddenhagen
    Contact: http://www.qt.io/licensing/

License:
    You may use this file under the terms of the 3-clause BSD license.
EOM
}

my $from_base;
my $from;
my $commit_count = 0;
my $ref_base;
my $ref_base_ok = 1;
my $ref_to;
my $force_branch = 0;
my $topic;
my $force = 0;
my $list_only = 0;
my $list_online = 0;

my @reviewers;
my @CCs;

sub parse_arguments(@)
{
    while (scalar @_) {
        my $arg = shift @_;

        if ($arg eq "-v" || $arg eq "--verbose") {
            $verbose = 1;
        } elsif ($arg eq "-q" || $arg eq "--quiet") {
            $quiet = 1;
        } elsif ($arg eq "--debug") {
            $debug = 1;
            $verbose = 1;
        } elsif ($arg eq "-n" || $arg eq "--dry-run") {
            $dry_run = 1;
        } elsif ($arg eq "-f" || $arg eq "--force") {
            $force = 1;
        } elsif ($arg eq "-r" || $arg eq "--remote") {
            fail("--remote needs an argument.\n") if (!@_ || ($_[0] =~ /^-/));
            $remote = shift @_;
        } elsif ($arg eq "-t" || $arg eq "--topic") {
            fail("--topic needs an argument.\n") if (!@_ || ($_[0] =~ /^-/));
            $topic = shift @_;
        } elsif ($arg eq "-b" || $arg eq "--branch") {
            fail("--branch needs an argument.\n") if (!@_ || ($_[0] =~ /^-/));
            $ref_to = shift @_;
        } elsif ($arg eq "-fb" || $arg eq "--force-branch") {
            $force_branch = 1;
        } elsif ($arg eq "-o" || $arg eq "--onto" || $arg eq "--base") {
            fail("--onto needs an argument.\n") if (!@_ || ($_[0] =~ /^-/));
            $ref_base = shift @_;
        } elsif ($arg eq "-l" || $arg eq "--list") {
            $list_only = 1;
        } elsif ($arg eq "-ll" || $arg eq "--list-online") {
            $list_only = 1;
            $list_online = 1;
        } elsif ($arg eq "--aliases") {
            foreach my $key (sort(keys %aliases)) {
                print "$key = $aliases{$key}\n";
            }
            exit 0;
        } elsif ($arg eq "-?" || $arg eq "--?" || $arg eq "-h" || $arg eq "--help") {
            usage();
            exit 0;
        } elsif ($arg =~ /^\+(.+)/) {
            push @reviewers, split(/,/, lookup_alias($1));
        } elsif ($arg =~ /^\=(.+)/) {
            push @CCs, split(/,/, lookup_alias($1));
        } elsif ($arg !~ /^\-/) {
            fail("Specifying multiple sources is currently not supported.\n")
                if (defined($from));
            # The assumption that no legitimate branch would have a purely numerical
            # name seems reasonable, so this overloading of the syntax should be safe.
            if ($arg =~ /^(.*):(\d+)$/) {
                $from = length($1) ? $1 : 'HEAD';
                $commit_count = $2;
            } elsif ($arg =~ /(.*):(.*)/) {
                if (length($1)) {
                    $from = $1;
                    print STDERR "Warning: Specifying <from>: is deprecated.".
                                 " Use just <from> instead.\n";
                }
                if (length($2)) {
                    $ref_to = $2;
                    print STDERR "Warning: Specifying :<ref-to> is deprecated.".
                                 " Use --branch instead.\n";
                }
            } else {
                $from = $arg;
            }
        } else {
            fail("Unrecognized option '$arg'.\n");
        }
    }

    fail("--quiet and --verbose/--debug are mutually exclusive.\n")
        if ($quiet && $verbose);

    if (!defined($from)) {
        $from = "HEAD";
    } else {
        if ($from =~ /^(.*)\.\.(.*)$/) {
            fail("Specifying a commit count and a range base are mutually exclusive.\n")
                if ($commit_count);
            ($from_base, $from) = (length($1) ? $1 : '@{u}', length($2) ? $2 :'HEAD');
        }
    }

    my $push_specific =
            @reviewers || @CCs || $force || $force_branch
            || defined($remote) || defined($ref_to) || defined($topic);

    if ($list_only) {
        fail("--list/--list-online is incompatible with --quiet/--verbose.\n")
            if ($quiet || ($verbose && !$debug));
        fail("--list/--list-online is incompatible with push-modifying options.\n")
            if ($push_specific);
        fail("--list is incompatible with base-modifying options.\n")
            if (defined($ref_base) && !$list_online);
    }
}

sub process_config()
{
    load_config();
}

sub lookup_alias($)
{
    my ($user) = @_;

    my $alias = $aliases{$user};
    if (defined $alias && $alias ne "") {
        print "Resolved $user to $alias.\n" if ($verbose);
        return $alias;
    }

    return $user;
}

sub set_group_error($$$)
{
    my ($group, $style, $error) = @_;

    ($$group{error_style}, $$group{error}) = ($style, $error);
}

sub caption_group($)
{
    my ($group) = @_;

    my $changes = $$group{changes};
    my $to = $$group{branch};
    my $tos = defined($to) ? " for $to" : "";
    my $tpc = $$group{topic};
    my $tpcs = length($tpc) ? ", topic '$tpc'" : "";
    my ($pfx, $rmt) = $list_only
                          ? ("Series of",
                             ($list_online && length($tos)) ? " on '$remote'" : "")
                          : ("Pushing", " to '$remote'");
    return (sprintf("%s %d Change(s)%s%s%s:",
                    $pfx, int(@$changes), $tos, $rmt, $tpcs),
            $changes);
}

sub report_pushed_group($$)
{
    my ($reports, $group) = @_;

    my ($title, $changes) = caption_group($group);
    report_flowed($reports, $title);
    report_local_changes($reports, $changes);
    my $error = $$group{error};
    report_text($reports, $$group{error_style}, $error) if (defined($error));
}

sub report_pushed_changes($)
{
    my ($group) = @_;

    my @reports;
    report_pushed_group(\@reports, $group);
    return \@reports;
}

# Determine a singular value for a particular attribute from the Changes
# in a series. Conflicting values are an error.
sub aggregate_property($$$$)
{
    my ($group, $prop_name, $get_prop, $get_ann) = @_;

    my $changes = $$group{changes};
    my %prop_map = map { $_ => 1 } grep { $_ } map { $get_prop->($_) } @$changes;
    my @props = keys %prop_map;
    if (@props > 1) {
        foreach my $change (@$changes) {
            my $p = $get_prop->($change);
            $$change{annotation} = $get_ann->($p) if (defined($p));
        }
        set_group_error($group, 'flowed',
                        "Changes were previously pushed with mixed ${prop_name}s."
                        ." Please specify one.");
        fail_formatted(report_pushed_changes($group));
    }
    if (@props) {
        my $p = $props[0];
        print "Re-using $prop_name '$p'.\n" if ($debug);
        return $p;
    }
    return undef;
}

# Find _the_ branch the specified commit lives on. This can be the current
# branch (and other branches are ignored), or _one_ other branch.
sub branch_for_commit($)
{
    my ($commit) = @_;

    my $in_rebase;
    my $curbranch;
    my @otherbranches;
    my $branches = open_cmd_pipe(0, "git", "branch", "--contains", $commit);
    while (read_process($branches)) {
        if (/^\* \(/) {
            # New git versions will tell us the currently rebased branch.
            if (/^\* \(no branch, rebasing (.*)\)$/) {
                $curbranch = $1;
                $in_rebase = 1;
            }
            last;
        } elsif (/^\* (.*)$/) {
            $curbranch = $1;
            last;
        } elsif (/^  (.*)$/) {
            push @otherbranches, $1;
        }
    }
    close_process($branches);
    if (!defined($curbranch)) {
        # If the commit is not on the current branch, see if it is on _one_
        # other branch with an upstream branch.
        my @goodbranches;
        foreach my $other (@otherbranches) {
            push @goodbranches, $other if (defined(git_config("branch.$other.merge")));
        }
        $curbranch = $goodbranches[0] if (@goodbranches == 1);
    }
    return ($curbranch, $in_rebase);
}

# Extract the local branch from the specified source.
# There are four possibilities where the source revision may be located:
# - On any named branch in a regular state.
#   The branch is usable up to its tip, which may be pointed to by HEAD.
# - On the current named branch mid-rebase.
#   The branch is pointed to by HEAD, and is usable only up to this point.
# - On a detached head, possibly mid-rebase.
#   HEAD is the only reference and thus also the tip. There is no name.
# - Nowhere, except possibly in the reflog.
#   It is the tip, as there are no references. There is no name.
# Note that commits specified by SHA1 which live on exactly one named
# branch fall into the first case.
sub determine_local_branch($)
{
    my ($source) = @_;

    # First, try to extract a branch name directly.
    $local_branch = ($source =~ s/[~^].*$//r);
    if ($local_branch eq "HEAD") {
        my $sref = read_cmd_line(SOFT_FAIL, "git", "symbolic-ref", "-q", "HEAD");
        $local_branch = $sref if (!$?);
    }
    $local_branch =~ s,^refs/heads/,,;
    $local_tip = $local_refs{$local_branch};
    if (!defined($local_tip)) {
        # Next, try to deduce a branch from the commit.
        my $in_rebase;
        ($local_branch, $in_rebase) = branch_for_commit($source);
        # Cannot use the branch's tip mid-rebase, because the
        # referenced commits may have been rewritten already.
        $local_tip = $local_refs{$local_branch}
            if (defined($local_branch) && !$in_rebase);
    }
    setup_remotes($source);
    set_gerrit_config($remote);
}

# Determine the target branch for the given series.
# The local branch's upstream branch will be used, unless a target branch
# has been specified by the user.
sub determine_remote_branch($)
{
    my ($group) = @_;

    my $br = $ref_to;
    if (!defined($br)) {
        $br = aggregate_property($group, 'target',
                                 sub { $_[0]->{tgt} },
                                 sub { '  => '.$_[0] });
    }
    if (!defined($br)) {
        fail("Cannot deduce source branch for $from. Please use --branch.\n")
            if (!defined($local_branch));
        $br = git_config("branch.$local_branch.merge");
        fail("$local_branch has no upstream branch. Please use --branch.\n")
            if (!defined($br));
        $br =~ s,^refs/heads/,,;
    }
    $$group{branch} = $br;
}

sub determine_topic($)
{
    my ($group) = @_;

    my $tpc = $topic;
    if (!defined($tpc)) {
        # No topic was specified, so deduce it from the previous push(es).
        $tpc = aggregate_property($group, 'topic',
                                  sub { $_[0]->{topic} },
                                  sub { '  /'.$_[0] });
    }
    $$group{topic} = $tpc;
}

sub initialize_get_changes()
{
    my $commit = parse_local_rev($from, SPEC_TIP);
    if (!defined($commit)) {
        # The revspec might refer to a Change-Id.
        # We need a place to start from. We try only the current local branch -
        # trying multiple branches would be expensive, potentially ambiguous
        # (as the same Change-Id can exist multiple times), and probably not
        # very useful to start with.
        determine_local_branch('HEAD');
        # Get the pool of Changes to search in, and later to push from.
        analyze_local_branch('HEAD') or
            fail("No local Changes (from HEAD).\n");
        # Now try again.
        $commit = parse_local_rev_id($from, SPEC_TIP);
    } else {
        # We did not need to visit the current branch to find the tip,
        # so determine the branch from the tip now.
        $from = "HEAD".$from if ($from =~ /^[~^]/);
        determine_local_branch($from);
        # Get the pool of Changes to push from.
        # We don't limit the range and even overshoot if possible; the
        # performance impact of that should be negligible. A corner-case
        # benefit of this is a better error message when 1) the range base
        # is specified by change-id, 2) it is invalid by being a descendant
        # of the tip, and 3) the tip is NOT specified by change-id.
        analyze_local_branch($local_tip // ($from =~ s/[~^].*$//r)) or
            fail("No local Changes (from $from).\n");
    }
    return $commit;
}

sub finalize_get_changes($)
{
    my ($changes) = @_;

    my %group = (changes => $changes);
    return \%group;
}

# Get the list of local commits to push.
sub get_changes()
{
    my $tip = initialize_get_changes();
    # Assemble the series of Changes to push from the pool.
    my $changes;
    if (defined($from_base)) {
        my $base = parse_local_rev($from_base, SPEC_BASE);
        $changes = changes_from_commits(get_commits_base($base, $tip, $from_base, $from));
    } elsif ($commit_count) {
        $changes = changes_from_commits(get_commits_count($tip, $commit_count, $from));
    } else {
        $changes = changes_from_commits(get_commits_free($tip));
    }
    fail("Specified commit range is empty.\n") if (!@$changes);
    my $group = finalize_get_changes($changes);
    return $group;
}

sub check_merge($$);

sub check_merge($$)
{
    my ($parents, $failed) = @_;

    my $good = 1;
    foreach my $parentid (@$parents) {
        my $parent = $commit_by_id{$parentid};
        # If the parent is upstream, the merge is good.
        next if (!$parent);

        my $rparents = $$parent{parents};
        # Merges of (good) merges are also good.
        next if (@$rparents > 1 && check_merge($rparents, $failed));

        push @$failed, $parent;
        $good = 0;
    }
    return $good;
}

# Ensure that we don't implicitly create new PatchSets for non-1st
# parents of merges, as these would most likely target the wrong branch.
# TODO: this could be handled more nicely by doing recursive pushes
# instead of bailing out.
sub parents_pushed($$)
{
    my ($parents, $failed) = @_;

    foreach my $parentid (@$parents[1 .. $#$parents]) {
        next if (defined($gerrit_info_by_sha1{$parentid}));  # Gerrit knows it
        my $parent = $commit_by_id{$parentid};
        next if (!$parent);  # Already upstream
        push @$failed, $parent;
    }
    return !@$failed;
}

sub check_merges($)
{
    my ($group) = @_;

    foreach my $change (@{$$group{changes}}) {
        my $commit = $$change{local};
        my $parents = $$commit{parents};
        if (@$parents > 1) {
            my (@failed, $header);
            if (!check_merge($parents, \@failed)) {
                $header = ",----- Merge of non-upstream commit(s) -----\n";
                set_group_error($group, 'fixed',
                                "Maybe you forgot to use git gpull instead of git pull?\n");
            } elsif (!parents_pushed($parents, \@failed)) {
                $header = ",----- Parent merge(s) not pushed yet ------\n";
                set_group_error($group, 'fixed', "Please push the parent(s) first.\n");
            } else {
                next;
            }
            $$change{annotation} = '  [FAIL]';
            set_change_error($change, 'fixed',
                             $header.format_commits(\@failed, "| ")
                             ."`-------------------------------------------\n");
            fail_formatted(report_pushed_changes($group));
        }
    }
}

# Assign each local Change to a matching remote Change if possible,
# on the way complaining about creating duplicates.
sub map_remote_changes($)
{
    my ($group) = @_;

    my $changes = $$group{changes};
    my $br = $$group{branch};
    my (@bad_chg, %bad_br);
    foreach my $change (@$changes) {
        my $gis = $gerrit_infos_by_id{$$change{id}};
        next if (!$gis);
        my ($good, @bad);
        foreach my $gi (@$gis) {
            if ($$gi{branch} eq $br) {
                $good = $gi;
            } elsif ($$gi{status} ne "MERGED") {
                # MERGED Changes are ignored, to avoid false positives for cherry-picks.
                push @bad, $gi;
            }
        }
        if ($good) {
            $$change{gerrit} = $good;
            # This overrides the current value, which is just a cache.
            $$change{topic} = $$good{topic};
        } elsif (@bad && !$force_branch) {
            my @bbr = map { $$_{branch} } @bad;
            $$change{annotation} = '  ['.join(" ", sort @bbr).']';
            push @bad_chg, $change;
            $bad_br{$_} = 1 foreach (@bbr);
        }
    }
    if (@bad_chg) {
        my $reports = report_pushed_changes($group);
        my $tpfx = (@bad_chg == @$changes) ? "The" : "Some of the";
        my $tsfx = (keys(%bad_br) == 1) ? "a different branch" : "different branches";
        report_fixed($reports,
                     "$tpfx Change(s) were previously pushed only for $tsfx.\n",
                     "Please move them server-side, push for a matching branch,\n",
                     "or use --force-branch to continue nonetheless.\n");
        fail_formatted($reports);
    }
}

use constant {
    NEW => 'NEW',
    KNOWN => 'KNOWN',
    FORCE => 'FORCE',
    MISSING => 'MISSING',
    MODIFIED => 'MODIFIED',
    UNMODIFIED  => 'UNMODIFIED',
    OUTDATED => 'OUTDATED',
    MERGED => 'MERGED',
    REJECTED => 'REJECTED',
    FAILED => 'FAILED'
};

sub resolve_ref_base($)
{
    my ($queries) = @_;

    return if (!length($ref_base) || ($ref_base eq "ROOT"));
    print "Resolving specified push base ...\n" if ($debug);
    # Make sure we don't get confusing errors later.
    # Also, we need a full SHA1 we can compare.
    $ref_base = read_cmd_line(SOFT_FAIL, "git", "rev-parse", "--verify", $ref_base."^{commit}");
    fail("... while resolving --base commit.\n")
        if ($?);
    visit_local_commits([ $ref_base ]);
    if (!$commit_by_id{$ref_base}) {
        print "--base is upstream.\n" if ($debug);
    } else {
        print "--base needs Gerrit query.\n" if ($debug);
        # Note: this will not recognize direct-pushed commits. That isn't
        # really a problem, as the only expected use case for specifying
        # a non-upstream base is pushing on top of another pending review.
        push @$queries, "commit:".$ref_base;
        $ref_base_ok = 0;
    }
}

sub confirm_ref_base()
{
    return if ($ref_base_ok);
    fail("Specified --base commit is not known to Gerrit.\n")
        if (!defined($gerrit_info_by_sha1{$ref_base}));
}

sub determine_base($)
{
    my ($group) = @_;

    confirm_ref_base();
    my $base = $ref_base;
    if (!defined($base)) {
        # We base this on the target remote under the assumption that it will
        # be updated only when really necessary, unlike the origin remote.
        my $refs = $remote_refs{$remote};
        my $to = $$group{branch};
        $base = $refs && $$refs{$to};
        wfail("Remote '$remote' does not appear to have branch '$to'."
                ." Maybe fetch it?\n")
            if (!defined($base));
        print "Using upstream $base as base.\n" if ($verbose);
    }
    $$group{base} = $base;
}

sub rebase_commit($$)
{
    my ($commit, $base_id) = @_;

    my $parents = $$commit{parents};
    my $parent_id = get_1st_commit($parents);

    # Technically, it would be possible to rebase merges along the
    # first parents, but there is no point in supporting this here.
    return if (@$parents > 1);

    my ($tree, $errors);
    my $parent = $commit_by_id{$parent_id};
    my $base = $commit_by_id{$base_id};
    if ($base && $parent && ($$base{tree} eq $$parent{tree})) {
        # The parent commits differ, but their trees are the same.
        $tree = $$commit{tree};
    } else {
        ($tree, $errors) = apply_diff($commit, $base_id, USE_STDERR);
        return (undef, $errors) if (!defined($tree));
    }

    my $new_parents = ($base_id eq 'ROOT') ? [] : [ $base_id ];
    my $new_commit = create_commit(
            $new_parents, $tree, $$commit{message},
            $$commit{author}, $$commit{committer});
    $$new_commit{changeid} = $$commit{changeid};
    $$new_commit{subject} = $$commit{subject};
    return $new_commit;
}

my $have_conflicts = 0;

sub do_rebase_changes($)
{
    my ($group) = @_;
    my ($base, $changes) = ($$group{base}, $$group{changes});

    if (get_1st_parent($$changes[0]{local}) eq $base) {
        $$_{final} = $$_{local} foreach (@$changes);
        print "Not rebasing - base is already $base.\n" if ($verbose);
        return;
    }

    printf("Rebasing %d commit(s) to %s.\n", int(@$changes), format_id($base))
        if ($verbose);

    for (my $idx = 0; $idx < @$changes; ) {
        my $change = $$changes[$idx];
        my $commit = $$change{local};
        printf("Rebasing [%d] %s\n", $idx, format_commit($commit, -14)) if ($debug);
        my ($new_commit, $errors) = rebase_commit($commit, $base);
        if (!$new_commit) {
            if (!defined($errors)) {
                set_change_error($change, 'oneline',
                                 "Rebasing merges is not supported.");
            } else {
                set_change_error($change, 'fixed',
                                 ",----- Failed to rebase commit ------\n"
                                 .($errors =~ s/^/| /mgr)
                                 ."\`------------------------------------\n");
            }
            $$change{freshness} = FAILED;
            $have_conflicts++;
            last;
        }
        printf("Picked as %s\n", format_id($$new_commit{id})) if ($debug);
        %commit2diff = ();
        $$change{final} = $new_commit;
        $base = $$new_commit{id};
        $idx++;
    }
}

sub rebase_changes($)
{
    my ($group) = @_;

    with_local_git_index(\&do_rebase_changes, $group);
}

sub classify_changes_offline($)
{
    my ($group) = @_;

    foreach my $change (@{$$group{changes}}) {
        if (defined($$change{pushed})) {
            # We would need to rebase to know, but we didn't, so make no
            # particular claims about the exact state.
            $$change{freshness} = KNOWN;
        } else {
            $$change{freshness} = NEW;
        }
    }
}

my $have_rejected = 0;
my $have_modified = 0;
my $need_force = 0;

sub classify_changes_online($)
{
    my ($group) = @_;

    foreach my $change (@{$$group{changes}}) {
        my $commit = $$change{final};
        last if (!$commit);  # Rebase failure
        my $sha1 = $$commit{id};
        my $ginfo = $$change{gerrit};
        my $status = $ginfo && $$ginfo{status};
        my $curr_sha1 = $ginfo && $$ginfo{revs}[-1]{id};
        my $chg_revs = $ginfo && $$ginfo{rev_by_id};
        my $this_rev = $chg_revs && $$chg_revs{$sha1};
        if ($this_rev) {
            $$change{patchset} = $$this_rev{ps};
            $$change{freshness} =
                ($status eq 'MERGED') ? MERGED :
                ($sha1 eq $curr_sha1) ? UNMODIFIED : OUTDATED;
        } elsif ($ginfo && ($status ne 'NEW')) {
            # We are attempting a push which Gerrit will reject anyway.
            my $err;
            if ($status eq 'MERGED') {
                $err = "Change is already MERGED; use git gpull to rebase.";
            } elsif ($status eq 'STAGED' || $status eq 'INTEGRATING') {
                $err = "Change is currently $status; cannot proceed.";
            } elsif ($status eq 'DEFERRED' || $status eq 'ABANDONED') {
                $err = "Change is $status; please restore it first.";
            } else {
                $err = "Change is in unknown state '$status'. I'm stumped. :}";
            }
            set_change_error($change, 'oneline', $err);
            $$change{freshness} = REJECTED;
            $have_rejected++;
        } else {
            # Finally, check whether the current PatchSet on Gerrit meets our
            # expectations, so we don't accidentally play ping-pong.
            my $pushed = $$change{pushed};
            if ($ginfo) {
                if (!defined($pushed) || ($pushed ne $curr_sha1)) {
                    # Having no pushed commit may indicate either that gpick --check
                    # was not used or that it found divergence. It doesn't appear
                    # useful to differentiate between the two.
                    my $pushed_rev = defined($pushed) && $$chg_revs{$pushed};
                    $$change{patchset} = $pushed_rev ? $$pushed_rev{ps} : "?";
                    $$change{freshness} = FORCE;
                    $need_force = 1;
                } else {
                    $$change{freshness} = MODIFIED;
                }
            } else {
                if (defined($pushed)) {
                    $$change{freshness} = MISSING;
                    $need_force = 1;
                } else {
                    $$change{freshness} = NEW;
                }
            }
            $have_modified++;
        }
    }
}

sub annotate_changes($)
{
    my ($group) = @_;

    foreach my $change (@{$$group{changes}}) {
        my @attribs;
        # Changes in the 'modified' state (that is, the ones for which pushing
        # actually has an effect) are annotated, while 'unmodified' ones are not.
        # This behavior has been chosen after much deliberation following the
        # principle that "no-op" should be silent, despite the fact that "doing
        # nothing" is a diversion from what a regular git push would do, and is
        # thus potentially confusing - but as having no modified changes at all
        # leads to an additional message, the less noisy output (assuming that
        # most Changes are usually not modified) seems most sensible.
        my $freshness = $$change{freshness};
        if (defined($freshness) && ($freshness ne UNMODIFIED) && ($freshness ne KNOWN)) {
            $freshness = "PS$$change{patchset}/$freshness"
                if ($freshness eq OUTDATED || $freshness eq FORCE);
            push @attribs, $freshness;
        }
        $$change{annotation} = '  ['.join('; ', @attribs).']'
            if (@attribs);
    }
}

sub make_listing($)
{
    my ($group) = @_;

    annotate_changes($group);
    return report_pushed_changes($group);
}

sub show_changes($)
{
    my ($group) = @_;

    print format_reports(make_listing($group));
}

sub fail_push($@)
{
    my ($group, @msgs) = @_;

    my $reports = make_listing($group);
    report_fixed($reports, @msgs);
    fail_formatted($reports);
}

sub print_errors($)
{
    my ($group) = @_;

    fail_push($group, "Please specify a different base.\n")
        if ($have_conflicts);
    fail_push($group, "Giving up - push is going to be rejected.\n")
        if ($have_rejected);
    fail_push($group, "Local state is out of sync with Gerrit.\n",
                      "Please use git gpick, or specify --force to push nonetheless.\n")
        if ($need_force && !$force);
}

sub add_if_unmodified($$)
{
    my ($change, $list) = @_;

    my $freshness = $$change{freshness};
    if (($freshness eq UNMODIFIED) || ($freshness eq OUTDATED)) {
        push @$list, $$change{final}{id};
    }
}

sub prepare_meta($)
{
    my ($group) = @_;

    my @invite_list;
    my (%invite_rvrs, %invite_ccs);
    if (@reviewers || @CCs) {
        foreach my $change (@{$$group{changes}}) {
            my $ginfo = $$change{gerrit};
            my $rvrs = $ginfo ? $$ginfo{reviewers} : {};
            my $any;
            foreach my $rvr (@reviewers) {
                if (($$rvrs{$rvr} // RVRTYPE_NONE) != RVRTYPE_REV) {
                    $invite_rvrs{$rvr} = 1;
                    $any = 1;
                }
            }
            foreach my $cc (@CCs) {
                if (($$rvrs{$cc} // RVRTYPE_NONE) != RVRTYPE_CC) {
                    $invite_ccs{$cc} = 1;
                    $any = 1;
                }
            }
            # Can't add reviewers to unmodified Changes with a push.
            add_if_unmodified($change, \@invite_list) if ($any);
        }
    }
    $$group{add_rvrs} = [ keys %invite_rvrs ];
    $$group{add_ccs} = [ keys %invite_ccs ];
    $$group{invite_list} = \@invite_list;

    my @topic_list;
    my $tpc = $$group{topic};
    if (defined($tpc)) {
        my $any;
        foreach my $change (@{$$group{changes}}) {
            next if ($tpc eq ($$change{topic} // ""));
            $any = 1;
            # Can't set topic of unmodified Changes with a push.
            add_if_unmodified($change, \@topic_list);
        }
        $$group{topic} = undef if (!$any);
    }
    $$group{topic_list} = \@topic_list;
}

sub push_changes($)
{
    my ($group) = @_;

    my $from = $$group{changes}[-1];
    my $tip = $$from{final}{id};
    my $to = $$group{branch};
    my $tpc = $$group{topic};
    my ($rvrs, $ccs) = ($$group{add_rvrs} // [], $$group{add_ccs} // []);

    my @push_options;
    push @push_options, "topic=$tpc" if (defined($tpc));
    push @push_options, map { "r=$_" } @$rvrs;
    push @push_options, map { "cc=$_" } @$ccs;

    my @gitcmd = ("git", "push");
    push @gitcmd, '-v' if ($verbose);
    push @gitcmd, '-q' if ($quiet);
    push @gitcmd, '-n' if ($dry_run);
    push @gitcmd, map { ("-o", "$_") } @push_options;
    push @gitcmd, $remote, "$tip:refs/for/$to";

    run_process(FWD_OUTPUT, @gitcmd);
}

sub update_unpushed($)
{
    my ($group) = @_;

    my $invite_list = $$group{invite_list};
    if (@$invite_list) {
        print "Inviting reviewers/CCs to unmodified commit(s) ...\n";
        my ($rvrs, $ccs) = ($$group{add_rvrs} // [], $$group{add_ccs} // []);
        my @rlist;
        foreach my $rvr (@$rvrs) {
            push @rlist, { "reviewer" => $rvr, "state" => "REVIEWER" };
        }
        foreach my $cc (@$ccs) {
            push @rlist, { "reviewer" => $cc, "state" => "CC" };
        }
        my $json = { "reviewers" => \@rlist };
        my $pipe = open_process(USE_STDIN | FWD_OUTPUT | DRY_RUN,
                                'ssh', @gerrit_ssh, 'gerrit', 'review', '--json',
                                @$invite_list);
        write_process($pipe, encode_json($json)."\n");
        close_process($pipe);
    }

    my $topic_list = $$group{topic_list};
    if (@$topic_list) {
        # TODO: This can be done with the REST API.
        print "Warning: Cannot set topic on unmodified commits.\n";
    }
}

sub update_state($)
{
    my ($group) = @_;

    my ($branch, $tpc) = ($$group{branch}, $$group{topic});
    # Setting an empty topic clears the previous topic from the server.
    $tpc = undef if (defined($tpc) && !length($tpc));
    foreach my $change (@{$$group{changes}}) {
        my $sha1 = $$change{final}{id};
        if (($$change{pushed} // "") ne $sha1) {
            $$change{pushed} = $sha1;
            $$change{topic} = $tpc;
        }
        $$change{tgt} = $branch;
    }
}

sub execute_pushing()
{
    my $online = !$list_only || $list_online;
    my $group = get_changes();
    my $pushed_changes = $$group{changes};
    if ($online) {
        my @queries = map { "change:".$$_{id} } @$pushed_changes;
        push @queries,
                map { "commit:".$_ }
                # Only ones that are not upstream yet.
                grep { $commit_by_id{$_} }
                # Only 2nd+ parents of local commits.
                map { @$_ > 1 ? @$_[1 .. $#$_] : () }
                map { $$_{local}{parents} } @$pushed_changes;
        resolve_ref_base(\@queries);
        my @args;
        push @args, "--all-reviewers" if (@reviewers || @CCs);
        query_gerrit(\@queries, \@args);
    }
    determine_remote_branch($group);
    if ($online) {
        check_merges($group);
        map_remote_changes($group);
    }
    determine_topic($group);
    if ($online) {
        determine_base($group);
        rebase_changes($group);
        classify_changes_online($group);
    } elsif (!$quiet) {
        classify_changes_offline($group);
    }
    if ($list_only) {
        show_changes($group);
        print "Not pushing - list mode.\n" if ($debug);
    } else {
        print_errors($group);
        show_changes($group) if (!$quiet);
        prepare_meta($group);
        if ($have_modified) {
            push_changes($group);
        } else {
            print "No modified commits - nothing to push.\n" if (!$quiet);
        }
        update_unpushed($group);

        # This makes sense even if no modified commits are pushed
        # (e.g., syncing state after a dumb push).
        update_state($group);
    }
}

process_config();
parse_arguments(@ARGV);
goto_gitdir();
load_state(0);
execute_pushing();
save_state($dry_run);
